Im having issues with my pathfinding. Im not sure if the issue is with the pathfinding function, or the map/graph construction. First, here is the test results:
➜  station_alpha git:(master) ✗ lua ./testing/__tests__/pathfinder.lua

.F.FF

Failed tests:

-------------

1) TestPathFinder.testGeneric

./testing/__tests__/pathfinder.lua:38: Path length does not match

expected: 4, actual: 7

stack traceback:

        ./testing/__tests__/pathfinder.lua:38: in upvalue 'TestPathFinder.testGeneric'

2) TestPathFinder.testNoPathAvailable

./testing/__tests__/pathfinder.lua:78: Expected no path to be found due to blockage

expected: nil, actual: {

    {x=5, y=5},

    {x=5, y=4},

    {x=4, y=4},

    {x=4, y=3},

    {x=3, y=3},

    {x=3, y=2},

    {x=2, y=2}

}

stack traceback:

        ./testing/__tests__/pathfinder.lua:78: in upvalue 'TestPathFinder.testNoPathAvailable'

3) TestPathFinder.testSingleStepPath

./testing/__tests__/pathfinder.lua:101: X position does not match at index 1

expected: 32, actual: 2

stack traceback:

        ./testing/__tests__/pathfinder.lua:101: in upvalue 'TestPathFinder.testSingleStepPath'

Ran 5 tests in 0.002 seconds, 2 successes, 3 failures, 
and the test suite: 
package.path = package.path
    .. ";./?.lua;./game/?.lua;./game/utils/?.lua;./game/components/?.lua;./game/systems/?.lua"

local luaunit = require("testing.luaunit")
Logger = require("logger")
local Vec2 = require("utils.Vec2")
local PathFinder = require("systems.PathFinder")
local MapManager = require("systems.MapManager")
local EntityManager = require("systems.EntityManager")
local constants = require("utils.constants")

local function createMockMapManager(width, height)
    EntityManager.components = {}
    EntityManager.entities = {}
    local mapManager = MapManager.new(EntityManager, width, height)
    mapManager:createLevelMap()
    return mapManager
end

-- Test case for PathFinder
TestPathFinder = {}

function TestPathFinder:testGeneric()
    local mapManager = createMockMapManager(5, 5)
    local startWorldPos = Vec2.new(1 * constants.pixelSize, 1 * constants.pixelSize) -- (1,1)
    local endWorldPos = Vec2.new(4 * constants.pixelSize, 4 * constants.pixelSize) -- (4,4)

    local pathFinder = PathFinder.new()
    local path = pathFinder:findPath(startWorldPos, endWorldPos, mapManager)

    local expectedPath = {
        Vec2.new(1 * constants.pixelSize, 1 * constants.pixelSize),
        Vec2.new(2 * constants.pixelSize, 2 * constants.pixelSize),
        Vec2.new(3 * constants.pixelSize, 3 * constants.pixelSize),
        Vec2.new(4 * constants.pixelSize, 4 * constants.pixelSize),
    }

    luaunit.assertEquals(#path, #expectedPath, "Path length does not match")
    for i, v in ipairs(path) do
        luaunit.assertEquals(
            v.x,
            expectedPath[i].x,
            "X position does not match at index " .. i
        )
        luaunit.assertEquals(
            v.y,
            expectedPath[i].y,
            "Y position does not match at index " .. i
        )
    end
end

function TestPathFinder:testEdgeCase()
    local mapManager = createMockMapManager(5, 5)

    -- Out of bounds start position
    local startWorldPos = Vec2.new(-1 * constants.pixelSize, -1 * constants.pixelSize) -- (-1,-1)
    local endWorldPos = Vec2.new(4 * constants.pixelSize, 4 * constants.pixelSize) -- (4,4)

    local pathFinder = PathFinder.new()
    local path = pathFinder:findPath(startWorldPos, endWorldPos, mapManager)

    luaunit.assertNil(path, "Expected no path found due to out of bounds start position")
end

function TestPathFinder:testNoPathAvailable()
    local mapManager = createMockMapManager(5, 5)

    -- Block the path
    mapManager.graph[2][2].style = require("utils.enums").TopographyType.INACCESSIBLE

    local startWorldPos = Vec2.new(1 * constants.pixelSize, 1 * constants.pixelSize) -- (1,1)
    local endWorldPos = Vec2.new(4 * constants.pixelSize, 4 * constants.pixelSize) -- (4,4)

    local pathFinder = PathFinder.new()
    local path = pathFinder:findPath(startWorldPos, endWorldPos, mapManager)

    luaunit.assertNil(path, "Expected no path to be found due to blockage")
end

function TestPathFinder:testSingleStepPath()
    local mapManager = createMockMapManager(5, 5)

    local startWorldPos = Vec2.new(1 * constants.pixelSize, 1 * constants.pixelSize) -- (1,1)
    local endWorldPos = Vec2.new(2 * constants.pixelSize, 1 * constants.pixelSize) -- (1,2)

    local pathFinder = PathFinder.new()
    local path = pathFinder:findPath(startWorldPos, endWorldPos, mapManager)

    local expectedPath = {
        Vec2.new(1 * constants.pixelSize, 1 * constants.pixelSize),
        Vec2.new(2 * constants.pixelSize, 1 * constants.pixelSize),
    }

    luaunit.assertEquals(
        #path,
        #expectedPath,
        "Path length does not match for single step"
    )
    for i, v in ipairs(path) do
        luaunit.assertEquals(
            v.x,
            expectedPath[i].x,
            "X position does not match at index " .. i
        )
        luaunit.assertEquals(
            v.y,
            expectedPath[i].y,
            "Y position does not match at index " .. i
        )
    end
end

function TestPathFinder:testMultiplePaths()
    local mapManager = createMockMapManager(5, 5)

    -- Setup a map with multiple paths
    mapManager.graph[2][2].style = require("utils.enums").TopographyType.INACCESSIBLE
    mapManager.graph[2][3].style = require("utils.enums").TopographyType.INACCESSIBLE

    local startWorldPos = Vec2.new(1 * constants.pixelSize, 1 * constants.pixelSize) -- (1,1)
    local endWorldPos = Vec2.new(4 * constants.pixelSize, 4 * constants.pixelSize) -- (4,4)

    local pathFinder = PathFinder.new()
    local path = pathFinder:findPath(startWorldPos, endWorldPos, mapManager)

    luaunit.assertNotNil(path, "Expected a path to be found")
    luaunit.assertNotEquals(#path, 0, "Expected path length to be greater than 0")
end

-- Run the tests
os.exit(luaunit.LuaUnit.run())
and the relevant code:
--mapmanager--
local Vec2 = require("utils.Vec2")
local constants = require("utils.constants")
local Topography = require("components.Topography")
local Shape = require("components.Shape")
local Texture = require("components.Texture")
local enums = require("utils.enums")
local Tile = require("components.Tile")
local ComponentType = enums.ComponentType
local ShapeType = enums.ShapeType
local TopographyType = enums.TopographyType

--- @class MapManager
--- @field entityManager     EntityManager
--- @field width         integer
--- @field height        integer
--- @field graph         table<number, table<number, Tile>>
--- @field dirtyGraph    boolean
local MapManager = {}
MapManager.__index = MapManager

--- @param entityManager   EntityManager
--- @param width       integer
--- @param height      integer
function MapManager.new(entityManager, width, height)
    local self = setmetatable({}, MapManager)
    self.entityManager = entityManager
    self.width = width
    self.height = height
    self.graph = {} -- will hold the A* graph
    self.dirtyGraph = true -- first build is required
    return self
end

local TopographyMap = {
    [TopographyType.OPEN] = 1.0,
    [TopographyType.ROUGH] = 0.5,
    [TopographyType.INACCESSIBLE] = 0,
}

function MapManager:rollTopography()
    local val = math.random()
    --for simple testing purposes, as even this is failing
    if val < 1 then
        return {
            style = TopographyType.OPEN,
            speedMultiplier = TopographyMap[TopographyType.OPEN],
            color = { r = 0.0, g = 1.0, b = 0.0 },
        }
    elseif val < 0.85 then
        return {
            style = TopographyType.ROUGH,
            speedMultiplier = TopographyMap[TopographyType.ROUGH],
            color = { r = 0.0, g = 0.0, b = 1.0 },
        }
    else
        return {
            style = TopographyType.INACCESSIBLE,
            speedMultiplier = TopographyMap[TopographyType.INACCESSIBLE],
            color = { r = 1.0, g = 0.0, b = 0.0 },
        }
    end
end

---@param xIndex integer
---@param yIndex integer
---@return integer
function MapManager:createCell(xIndex, yIndex)
    local result = self:rollTopography()

    local tileId = self.entityManager:createEntity()

    self.entityManager:addComponent(
        tileId,
        ComponentType.POSITION,
        Vec2.new((xIndex - 1) * constants.pixelSize, (yIndex - 1) * constants.pixelSize)
    )
    self.entityManager:addComponent(
        tileId,
        ComponentType.TEXTURE,
        Texture.new(result.color)
    )
    self.entityManager:addComponent(
        tileId,
        ComponentType.SHAPE,
        Shape.new(ShapeType.SQUARE, constants.pixelSize)
    )
    self.entityManager:addComponent(
        tileId,
        ComponentType.TOPOGRAPHY,
        Topography.new(result.style, result.speedMultiplier)
    )
    self.entityManager:addComponent(
        tileId,
        ComponentType.MAPTILETAG,
        Vec2.new(xIndex, yIndex)
    )
    return tileId
end

function MapManager:createLevelMap()
    local tiles = {}
    for y = 1, self.height do
        tiles[y] = {}
        for x = 1, self.width do
            local tileId = self:createCell(x, y)
            local tile = Tile.new(x, y, tileId)
            tiles[y][x] = tile
        end
    end
    self.graph = tiles -- Now it's a 2D grid of Tiles
    self:buildGraph()
end

function MapManager:buildGraph()
    local dirs = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } }
    for y = 1, self.height do
        for x = 1, self.width do
            local tile = self.graph[y][x]
            tile.neighbors = {}
            for _, d in ipairs(dirs) do
                local nx, ny = x + d[1], y + d[2]
                if nx >= 1 and nx <= self.width and ny >= 1 and ny <= self.height then
                    local neighbor = self.graph[ny][nx]
                    if neighbor.style ~= TopographyType.INACCESSIBLE then
                        table.insert(tile.neighbors, neighbor)
                    end
                end
            end
        end
    end
    self.dirtyGraph = false
end

--- Rebuild the graph only when dirty – call once per frame.
--- @return nil
function MapManager:update()
    if self.dirtyGraph then
        self:buildGraph()
    end
end

--- Retrieve a node from the current graph.
--- @param x integer
--- @param y integer
--- @return Tile|nil
function MapManager:getNode(x, y)
    return self.graph and self.graph[x] and self.graph[x][y]
end

--- Convert a world position to grid indices.
--- @param pos Vec2
--- @return Vec2
function MapManager:worldToGrid(pos)
    local x = math.floor(pos.x / constants.pixelSize) + 1
    local y = math.floor(pos.y / constants.pixelSize) + 1
    return Vec2.new(x, y)
end

--- Convert grid indices back to world coordinates (center of tile).
--- @param x integer
--- @param y integer
--- @return Vec2
function MapManager:gridToWorld(x, y)
    local wx = (x - 1) * constants.pixelSize + constants.pixelSize / 2
    local wy = (y - 1) * constants.pixelSize + constants.pixelSize / 2
    return Vec2.new(wx, wy)
end

--- @param x          integer
--- @param y          integer
--- @param newStyle   TopographyType
function MapManager:updateTileStyle(x, y, newStyle)
    local tile = self.graph[x] and self.graph[x][y]
    if not tile then
        return
    end

    local entity = self.entityManager:getComponent(tile.id, ComponentType.TOPOGRAPHY)
    self.entityManager:addComponent(entity, ComponentType.TOPOGRAPHY, newStyle)

    self.dirtyGraph = true
end

--- Get the style table for a tile (cached or read from its entity).
--- @param x integer
--- @param y integer
--- @return TopographyType|nil
function MapManager:getTileStyle(x, y)
    local tile = self.graph[x] and self.graph[x][y]
    if not tile then
        return nil
    end

    local topography = self.entityManager:getComponent(tile.id, ComponentType.TOPOGRAPHY)

    return topography
end

return MapManager

--pathfinder--
local Tile = require("components.Tile")

---@class Pathfinder
---@field nodePool table<integer, Tile>
---@field poolIndex integer
local PathFinder = {}
PathFinder.__index = PathFinder

--- Create a new, empty Pathfinder instance.
--- @return Pathfinder
function PathFinder.new()
    local self = setmetatable({}, PathFinder)
    self.nodePool = {}
    self.poolIndex = 1
    return self
end

---Return all pooled nodes to the pool and reset the index.
function PathFinder:releaseAll()
    self.nodePool = {}
    self.poolIndex = 1
end

---Grab a node from the pool (or create a new one) and init its bookkeeping fields.
---@param parent Tile?          -- parent node (nil for the start node)
---@param position Vec2          -- world position of the node
---@return table node            -- a reused node table
function PathFinder:obtainNode(parent, position)
    local n = self.nodePool[self.poolIndex]
    if n then
        self.poolIndex = self.poolIndex + 1
    else
        n = Tile.new(parent, position) -- first use, node creation
    end
    n.parent = parent
    n.position = position
    n.g = 0
    n.h = 0
    n.f = 0
    return n
end

---Insert a node into the min‑heap.
---@param heap   table<integer,Tile>   -- binary heap (min‑heap on `f`)
---@param node   table                  -- node to insert
function PathFinder:heapPush(heap, node)
    local i = #heap + 1
    heap[i] = node
    while i > 1 do
        local p = math.floor(i / 2)
        if heap[p].f <= heap[i].f then
            break
        end
        heap[i], heap[p] = heap[p], heap[i]
        i = p
    end
end

---@param heap table<integer,table>   -- binary heap
---@return table? -- node with the smallest `f` value
function PathFinder:heapPop(heap)
    if #heap == 0 then
        return nil
    end
    local min = heap[1]
    heap[1] = heap[#heap]
    heap[#heap] = nil
    local i = 1
    while true do
        local l = i * 2
        local r = l + 1
        if l > #heap then
            break
        end
        local smallest = l
        if r <= #heap and heap[r].f < heap[l].f then
            smallest = r
        end
        if heap[i].f <= heap[smallest].f then
            break
        end
        heap[i], heap[smallest] = heap[smallest], heap[i]
        i = smallest
    end
    return min
end

---@param startWorldPos Vec2
---@param endWorldPos Vec2
---@param mapManager MapManager
function PathFinder:findPath(startWorldPos, endWorldPos, mapManager)
    if not mapManager or not mapManager.graph or not mapManager.graph[1] then
        Logger:error("mapManager error")
        return nil
    end

    local startVec = mapManager:worldToGrid(startWorldPos)
    local endVec = mapManager:worldToGrid(endWorldPos)

    if not startVec or not endVec then
        Logger:error("start/end vec error")
        return nil
    end

    if
        startVec.x < 1
        or startVec.x > mapManager.width
        or startVec.y < 1
        or startVec.y > mapManager.height
        or endVec.x < 1
        or endVec.x > mapManager.width
        or endVec.y < 1
        or endVec.y > mapManager.height
    then
        Logger:error("bounds exceeded")
        return nil -- Return nil for out-of-bounds
    end

    -- Check bounds before accessing graph
    if
        not mapManager.graph[startVec.x]
        or not mapManager.graph[startVec.y]
        or not mapManager.graph[endVec.x]
        or not mapManager.graph[endVec.y]
    then
        Logger:error("bounds error")
        return nil
    end

    local startNode = mapManager.graph[startVec.x][startVec.y]
    local goalNode = mapManager.graph[endVec.x][endVec.y]

    if not startNode or not goalNode then
        Logger:error("start/end node error")
        return nil
    end

    -- Open / closed sets
    local open = {}
    local closedSet = {}

    -- Initialize closedSet properly
    for x = 1, #mapManager.graph do
        closedSet[x] = {}
        for y = 1, #mapManager.graph[x] do
            closedSet[x][y] = false
        end
    end

    local function isInOpenSet(node)
        for _, openNode in ipairs(open) do
            if
                openNode.position.x == node.position.x
                and openNode.position.y == node.position.y
            then
                return true
            end
        end
        return false
    end

    local function pushNode(node)
        node.g = node.parent and node.parent.g + 1 or 0
        node.h = (node.position.x - goalNode.position.x) ^ 2
            + (node.position.y - goalNode.position.y) ^ 2
        node.f = node.g + node.h
        self:heapPush(open, node)
    end

    local start = self:obtainNode(nil, startNode.position)
    pushNode(start)

    while #open > 0 do
        local current = self:heapPop(open)
        if current == nil then
            Logger:error("There was no node in the open set, this should never happen")
            return nil
        end

        -- Bounds check for current position
        if
            closedSet[current.position.x] == nil
            or closedSet[current.position.x][current.position.y] == nil
        then
            Logger:error(
                "Invalid position in closedSet: "
                    .. "x:"
                    .. current.position.x
                    .. ","
                    .. "y:"
                    .. current.position.y
            )
            return nil
        end

        closedSet[current.position.x][current.position.y] = true

        -- Check if we reached the goal
        if
            current.position.x == goalNode.position.x
            and current.position.y == goalNode.position.y
        then
            local path = {}
            local n = current
            while n do
                table.insert(path, n.position)
                n = n.parent
            end
            self:releaseAll()
            return path
        end

        local currentNode = mapManager.graph[current.position.x][current.position.y]

        for _, nbNode in ipairs(currentNode.neighbors or {}) do
            -- Validate neighbor node position
            if not nbNode.position then
                Logger:error("Missing position on neighbor node")
                Logger:error(nbNode)
                return nil
            end

            -- Bounds check for neighbor position
            if
                not mapManager.graph[nbNode.position.x]
                or not mapManager.graph[nbNode.position.x][nbNode.position.y]
            then
                Logger:debug(
                    "Neighbor node out of bounds: "
                        .. nbNode.position.x
                        .. ","
                        .. nbNode.position.y
                )
                goto continue_neighbor
            end

            -- Check if neighbor is already closed or in open set
            if
                not closedSet[nbNode.position.x][nbNode.position.y]
                and not isInOpenSet(nbNode)
            then
                local child = self:obtainNode(current, nbNode.position)
                pushNode(child)
            end

            ::continue_neighbor::
        end
    end

    self:releaseAll()
    return nil -- Explicitly return nil if no path found
end

return PathFinder.new()

--main.lua--
local enums = require("utils.enums")
local MapManager = require("systems.MapManager")
local ComponentType = enums.ComponentType
local ShapeType = enums.ShapeType
local TaskType = enums.TaskType
local EntityManager = require("systems.EntityManager")
local InputSystem = require("systems.Input")
local PositionSystem = require("systems.Position")
local RenderSystem = require("systems.Render")
local Camera = require("components.Camera")
local Vec2 = require("utils.Vec2")
local Texture = require("components.Texture")
local Shape = require("components.Shape")
local pathfinder = require("systems.PathFinder")
local constants = require("utils.constants")
local LoadingIndicator = require("components.LoadingIndicator")
local TaskQueue = require("components.TaskQueue")
local overlayStats = require("libs.OverlayStats")
Logger = require("logger"):init()

local mapManager

local function isLoading()
    if not mapManager.graph or mapManager.dirtyGraph == true then
        return true
    end
end

function love.load()
    Camera = Camera.new()
    mapManager = MapManager.new(EntityManager, constants.MAP_W / 10, constants.MAP_H / 10)
    mapManager:createLevelMap()

    ---temporary for demoing purposes---
    Dot = EntityManager:createEntity()
    EntityManager:addComponent(
        Dot,
        ComponentType.POSITION,
        Vec2.new(4 * constants.pixelSize, 3 * constants.pixelSize)
    )
    EntityManager:addComponent(Dot, ComponentType.VELOCITY, Vec2.new())
    EntityManager:addComponent(
        Dot,
        ComponentType.TEXTURE,
        Texture.new({ r = 1, g = 0.5, b = 0 })
    )
    EntityManager:addComponent(Dot, ComponentType.SHAPE, Shape.new(ShapeType.CIRCLE, 10))
    EntityManager:addComponent(Dot, ComponentType.TASKQUEUE, TaskQueue.new(Dot))
    ---temporary for demoing purposes---

    overlayStats.load()
end

function love.update(dt)
    MapManager:update()
    --InputSystem:update(EntityManager)
    PositionSystem:update(dt, EntityManager)
    Camera:update(dt)

    if isLoading() == true and LoadingIndicator.isVisible == false then
        LoadingIndicator:show()
    elseif isLoading() == false and LoadingIndicator.isVisible == true then
        LoadingIndicator:hide()
    end

    if LoadingIndicator.isVisible then
        LoadingIndicator:update(dt)
    end

    for e, _ in pairs(EntityManager.entities) do
        local tq = EntityManager:getComponent(e, ComponentType.TASKQUEUE)
        if tq then
            tq:update(dt, EntityManager)
        end
    end

    overlayStats.update(dt)
end

function love.keypressed(key, scancode, isrepeat)
    Logger:keypressed(key, scancode)
    overlayStats.handleKeyboard(key)
end

function love.mousepressed(x, y, button, istouch)
    if button == 1 then -- left‑click
        local worldX = (x / Camera.zoom) + Camera.position.x
        local worldY = (y / Camera.zoom) + Camera.position.y

        local clickVec = Vec2.new(worldX, worldY)
        local currentDotPos = EntityManager:getComponent(Dot, ComponentType.POSITION)

        local path = pathfinder:findPath(currentDotPos, clickVec, mapManager)
        if path == nil then
            return
        end

        if path and #path > 0 then
            local taskQueue = EntityManager:getComponent(Dot, ComponentType.TASKQUEUE)
            if taskQueue then
                for _, wp in ipairs(path) do
                    wp:mutMul(constants.pixelSize)
                    taskQueue:push({ type = TaskType.MOVETO, data = wp })
                end
            end
        end
    end
end

function love.wheelmoved(x, y)
    if love.keyboard.isDown("lctrl") then
        Logger:wheelmoved(x, y)
    else
        Camera:wheelmoved(x, y)
    end
end

function love.touchpressed(id, x, y, dx, dy, pressure)
    overlayStats.handleTouch(id, x, y, dx, dy, pressure)
end

function love.draw()
    Camera:apply()
    RenderSystem:update(EntityManager)
    Camera:unapply()
    LoadingIndicator:draw()
    Logger:draw()
    overlayStats.draw()
end
